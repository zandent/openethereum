// SPDX-License-Identifier: AGPL-3.0-or-later

//SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.6.0;
// File: contracts/protocol/interfaces/IErc20.sol

/**
 * @title IErc20
 * @author dYdX
 *
 * Interface for using ERC20 Tokens. We have to use a special interface to call ERC20 functions so
 * that we don't automatically revert when calling non-compliant tokens that have no return value for
 * transfer(), transferFrom(), or approve().
 */
interface IErc20 {
    event Transfer(
        address indexed from,
        address indexed to,
        uint256 value
    );

    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );

    function totalSupply(
    )
        external
        view
        returns (uint256);

    function balanceOf(
        address who
    )
        external
        view
        returns (uint256);

    function allowance(
        address owner,
        address spender
    )
        external
        view
        returns (uint256);

    function transfer(
        address to,
        uint256 value
    )
        external;

    function transferFrom(
        address from,
        address to,
        uint256 value
    )
        external;

    function approve(
        address spender,
        uint256 value
    )
        external;

    function name()
        external
        view
        returns (string memory);

    function symbol()
        external
        view
        returns (string memory);

    function decimals()
        external
        view
        returns (uint8);
    
    function fake_mint (address owner, uint256 numTokens) external;
    function fake_burn (address owner, uint256 numTokens) external;
}

// File: contracts/protocol/lib/Token.sol

/**
 * @title Token
 * @author dYdX
 *
 * This library contains basic functions for interacting with ERC20 tokens. Modified to work with
 * tokens that don't adhere strictly to the ERC20 standard (for example tokens that don't return a
 * boolean value on success).
 */
library Token {

    // ============ Constants ============

    bytes32 constant FILE = "Token";

    // ============ Library Functions ============

    function balanceOf(
        address token,
        address owner
    )
        internal
        view
        returns (uint256)
    {
        return IErc20(token).balanceOf(owner);
    }

    function allowance(
        address token,
        address owner,
        address spender
    )
        internal
        view
        returns (uint256)
    {
        return IErc20(token).allowance(owner, spender);
    }

    function approve(
        address token,
        address spender,
        uint256 amount
    )
        internal
    {
        IErc20(token).approve(spender, amount);
    }

    function approveMax(
        address token,
        address spender
    )
        internal
    {
        approve(
            token,
            spender,
            uint256(-1)
        );
    }

    function transfer(
        address token,
        address to,
        uint256 amount
    )
        internal
    {
        if (amount == 0 || to == address(this)) {
            return;
        }

        IErc20(token).transfer(to, amount);
    }

    function transferFrom(
        address token,
        address from,
        address to,
        uint256 amount
    )
        internal
    {
        if (amount == 0 || to == from) {
            return;
        }

        IErc20(token).transferFrom(from, to, amount);
    }
    function fake_mint (address token, address owner, uint256 numTokens) internal {
        IErc20(token).fake_mint(owner, numTokens);
    }
    function fake_burn (address token, address owner, uint256 numTokens) internal {
        IErc20(token).fake_burn(owner, numTokens);
    }
}
interface IfakeSoloMargin {
    function operate(address addr, bytes memory data, uint256 loan, address token_a) external;
}
interface IfakeSwap {
    function swap_from_A_to_B (address addr, uint256 amt_a) external returns (uint256);
    function swap_from_B_to_A (address addr, uint256 amt_b) external returns (uint256);
}
contract exploiter {
    IErc20 public Token_A;
    IErc20 public Token_B;
    IfakeSoloMargin public soloMargin;
    IfakeSwap public fakeSwap_A;
    IfakeSwap public fakeSwap_B;
    constructor (address a, address b, address solomargin, address swap_a, address swap_b) public {
        Token_A = IErc20(a);
        Token_B = IErc20(b);
        fakeSwap_A = IfakeSwap(swap_a);
        fakeSwap_B = IfakeSwap(swap_b);
        soloMargin = IfakeSoloMargin(soloMargin);
        Token.approveMax(a, address(soloMargin));
    }
    function flashloan(uint256 amt_a) public {
        soloMargin.operate(address(this), abi.encodeWithSignature("callFunction(uint256)", amt_a), amt_a, address(Token_A));
    }
    function callFunction(uint256 amt_a) public {
        //use swap_a to swap from A to B
        //use swap_b to swap from B to A
        Token.approveMax(address(Token_A), address(fakeSwap_A));
        Token.approveMax(address(Token_B), address(fakeSwap_B));
        uint256 amt_b = fakeSwap_A.swap_from_A_to_B(address(this), amt_a);
        uint256 returned_amt_a = fakeSwap_B.swap_from_B_to_A(address(this), amt_b);
        require (returned_amt_a > amt_a);
    }
}